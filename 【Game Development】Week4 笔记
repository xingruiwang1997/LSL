【AWSD键盘操纵物体rotation代码】：
using UnityEngine;
public class C_Rotation_Class : MonoBehaviour
{
    //是否启用手搓Quaternion的开关和float V4和V3不能混用
    [SerializeField] private bool Do_You_Use_Quaternion_To_Set_Rotation=false;
    [SerializeField] [Range(0,1)]private float x4,y4,z4,w4=1; //[1]My Own Quaternion Value
    //是否启用transform.Rotate(x,y,z)
    [SerializeField] private bool Do_You_Use_RotateByTime=false;
    [SerializeField] [Range(0,360)] private float x3,y3,z3;
    //用self还是world坐标，不能混用
    [SerializeField] private bool Do_You_Use_SelfSpace=true;
    [SerializeField] private bool Do_You_Use_WorldSpace=false;
    //自加，因为觉得打Time.deltaTime很麻烦
    private float T;
    //是否启用AWSD控制旋转，默认开
    [SerializeField] private bool Do_You_Use_AWSDRotation=true;
    private float WS;
    private float AD;
    private Vector3 AWSDRotation;
    [SerializeField]private float RotationSpeed=120f;//旋转速度，默认120f
    //Debug开关 默认关
    [SerializeField]private bool Debug_Quaternion=false;
    [SerializeField]private bool Debug_AWSD_GetAxis=false;
    void Start()
    {//啥也没有
    }
    void Update()//所有方法都写在Custom Void里了，VS软件里点击方法，对应部分会高亮。也可以Ctrl+F直接检索
    {
    LSL_SetTimedektaTime();//这里赋值一下deltaTime为T，只是我为了码字方便
    if(Do_You_Use_Quaternion_To_Set_Rotation){Class2_ResetQuaternion(); Do_You_Use_RotateByTime=false;}//打了勾才能用Quaternion，和Euler不能混用
    if(Do_You_Use_RotateByTime){Class3_Euler(); Do_You_Use_Quaternion_To_Set_Rotation=false;}//打勾才能有用这个Euler旋转
    if(Do_You_Use_AWSDRotation){LSL_GetAxisAWSDValue();Class5_AWSDtoRotation(); }//取得AWSD的值，并用AWSD旋转物体
    //Debug
    if(Debug_Quaternion)Class1_DebugRotation();//打了勾且 摁空格才能 debug，为了节省算力（因为我电脑是土豆显卡苹果CPU
    if(Debug_AWSD_GetAxis)Class4_Debug_GetAxis();//打了勾且 摁空格才能 debug，为了节省算力
    }
    //Custom Void
    void Class1_DebugRotation()//DEBUG可忽略
    {if(Input.GetKey(KeyCode.Space))Debug.Log(transform.rotation);}
    void Class2_ResetQuaternion()//启用quaternion旋转
    {transform.rotation=new Quaternion(x4,y4,z4,w4);}
    void Class3_Euler(){ //启用Euler旋转，可选self或world坐标
    if(Do_You_Use_SelfSpace){transform.Rotate(x3*T,y3*T,z3*T,Space.Self);Do_You_Use_WorldSpace=false;} //Multiply Time.deltaTime 这个用于不停的旋转
    if(Do_You_Use_WorldSpace){transform.Rotate(x3*T,y3*T,z3*T,Space.World); Do_You_Use_SelfSpace=false;}}//勾选选择world或者self坐标
    void LSL_SetTimedektaTime(){ //自用为了 因为觉得打Time.deltaTime很麻烦
     T=Time.deltaTime;}
    void Class4_Debug_GetAxis() {//Debug可忽略
    if (Input.GetKey(KeyCode.Space)) { 
    Debug.Log("WS Key Input:"+Input.GetAxis("Vertical"));  
    Debug.Log("AD Key Input:"+Input.GetAxis("Horizontal"));}}
    void LSL_GetAxisAWSDValue() {//Get到AWSD输入值；Unity自带输入系统
    WS=Input.GetAxis("Vertical");
    AD=Input.GetAxis("Horizontal");}
    void Class5_AWSDtoRotation() { //用AWSD值影响物体V3_rotate
    AWSDRotation=new Vector3(0,-AD,WS);
   if(Do_You_Use_SelfSpace){transform.Rotate(AWSDRotation*RotationSpeed*T, Space.Self);Do_You_Use_WorldSpace=false;}
   if(Do_You_Use_WorldSpace){transform.Rotate(AWSDRotation*RotationSpeed*T, Space.World);Do_You_Use_SelfSpace=false;}}
}

【物体PingPong移动代码】：
using System.Xml.Serialization;
using UnityEngine;
public class C_TargetMove_Class : MonoBehaviour
{
    //PingPong运动 距离&速度手调
    [SerializeField] private bool Do_You_Do_PingPongMovement=false;//是否开启pingpong运动？默认不开
    [SerializeField] private float PingPongSpeed=2f;//手调 运动速度
    [SerializeField] private float Ox,Oy,Oz;//手调物体的pingpong初始位置 voidStart后会被赋值，然后可以手调,调Ox，Oy，Oz改变它的pingpong起始位置
    private float Px, Py,Pz;
    //两者不能混用↓
    //方法1
    [SerializeField] private bool Use_Length=true;//是否用位置调整？默认开启
    [SerializeField] private float XMove,YMove,ZMove=0f;//手调 XYZ分别的pingpong距离 默认0，也就是不动
    //方法2
    [SerializeField] private bool Use_FinalPosition=false;//是否用最终距离调整？默认关闭
    [SerializeField] private float Fx,Fy,Fz;//手调最终的位置 默认和开始位置一样，所以默认不动
    private bool IsOxyzChanged=false;
    private float NOx,NOy,NOz;
    private float T;//自用，因为觉得打Time.Time很麻烦
    [SerializeField] private bool DebugTime=false;//开启会debugtime
    [SerializeField] private bool DebugFxyz=false;//开启会debug最终位置，只有打开 方法2 才能用
    void Start()
    {
    LSL_SetOriginalXYZ();//先取得初始坐标Ox，Oy，Oz，之后就可以inspector里面手调了
    }
    void Update()
    {
    LSL_SetTimeTime();//这里赋值一下deltaTime为T，只是我为了码字方便 
    if(Do_You_Do_PingPongMovement)C1_PingPong();//勾选后开启PingPong运动
    }
    //CUSTOM VOIDS
    void LSL_SetOriginalXYZ(){//Start里面先取得物体的初始位置
    Ox=transform.position.x; NOx=Ox;
    Oy=transform.position.y; NOy=Oy;
    Oz=transform.position.z; NOz=Oz;
    LSL_SetFinalPosition();}
    void LSL_SetTimeTime(){ //自用为了 因为觉得打Time.Time很麻烦
    T=Time.time;//Mathf.PingPong使用的是Time.time而不是deltatime
    if(DebugTime)Debug.Log("LSL：Time="+T);}//开关控制是否debugtime
    void C1_PingPong(){ //condition ? consequence : alternative 做条件判断
    //方法1
    if (Use_Length) {//两种设定pingpong最终距离的方式，随便用那种都可以，但是2者不能混用
    Use_FinalPosition=false;
    Px=XMove==0?Ox:Mathf.PingPong(t:PingPongSpeed*T,length:XMove)+Ox;//为了防止公式太长，分开写
    Py=YMove==0?Oy:Mathf.PingPong(t:PingPongSpeed*T,length:YMove)+Oy;//YMove=0的话，Pingpong的结果是NaN，所以直接赋值Oy，否则计算Pingpong
    Pz=ZMove==0?Oz:Mathf.PingPong(t:PingPongSpeed*T,length:ZMove)+Oz;}
    //方法2
    if (Use_FinalPosition) {//如果用最终位置调整的话，那么就Fx设定为Ox，最终位置默认=初始位置
    Use_Length=false;
    LSL_ChangeFtoO();//如果改变了初始位置O，最终位置F也一起改变
    if(DebugFxyz)Debug.Log($"LSL：FX={Fx},FY={Fy},FZ={Fz}");//Debug可忽略
    Px=Fx-Ox==0?Ox:Mathf.PingPong(t:PingPongSpeed*T,length:Fx-Ox)+Ox;
    Py=Fy-Oy==0?Oy:Mathf.PingPong(t:PingPongSpeed*T,length:Fy-Oy)+Oy;
    Pz=Fz-Oz==0?Oz:Mathf.PingPong(t:PingPongSpeed*T,length:Fz-Oz)+Oz;}
    transform.position=new Vector3 (Px,Py,Pz);}
    void LSL_ChangeFtoO(){
        if (NOx!=Ox||NOy!=Oy||NOz!=Oz) { 
            IsOxyzChanged=true;
            NOx=Ox;NOy=Oy;NOz=Oz;}
        if (IsOxyzChanged) {//只有当Oxyz变了的时候，才会重新赋值Fxyz
            LSL_SetFinalPosition();
            IsOxyzChanged=false;}}
    void LSL_SetFinalPosition(){
    Fx=Ox;Fy=Oy;Fz=Oz;}
}
